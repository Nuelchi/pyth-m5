<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TrainFlow - Backtesting Platform by SkyEx Corporation</title>
  <style>
    body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 0; background: #0b0f14; color: #e6edf3; }
    header { padding: 12px 16px; border-bottom: 1px solid #1f2a33; display: flex; gap: 12px; align-items: center; }
    label { font-size: 12px; color: #8b98a5; }
    input, select { background: #0e151b; border: 1px solid #1f2a33; color: #e6edf3; padding: 6px 8px; border-radius: 6px; }
    button { background: #1f6feb; color: white; border: 0; padding: 8px 12px; border-radius: 6px; cursor: pointer; }
    #fast { background: #2ea043; color: #0b0f14; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .row { display: flex; gap: 8px; align-items: end; flex-wrap: wrap; }
    .cell { display: flex; flex-direction: column; gap: 6px; }
    #chart { height: 680px; width: 100%; }
    #log { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; padding: 8px 12px; height: 180px; overflow: auto; background: #0e151b; border-top: 1px solid #1f2a33; }
  </style>

  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
  <header>
    <div style="text-align: center; margin-bottom: 12px; color: #8b98a5; font-size: 14px;">
      ðŸš€ TrainFlow - Professional Backtesting Platform by SkyEx Corporation
    </div>
    <div class="row">
      <div class="cell">
        <label>Symbol</label>
        <select id="symbol_select" style="min-width:140px"></select>
      </div>
      <div class="cell">
        <label>Custom symbol</label>
        <input id="symbol" value="EUR/USD" />
      </div>
      <div class="cell">
        <label>Market</label>
        <select id="market">
          <option value="forex" selected>Forex</option>
          <option value="stocks">Stocks</option>
          <option value="crypto">Crypto</option>
        </select>
      </div>
      <div class="cell">
        <label>Source</label>
        <select id="source">
          <option value="yfinance" selected>yfinance</option>
          <option value="mt5">MT5</option>
        </select>
      </div>
      <div class="cell">
        <label>Timeframe</label>
        <select id="timeframe">
          <option value="H1" selected>H1</option>
          <option value="M15">M15</option>
          <option value="D1">D1</option>
        </select>
      </div>
      <div class="cell">
        <label>Start</label>
        <input id="start" type="datetime-local" value="2025-05-18T17:32" />
      </div>
      <div class="cell">
        <label>End</label>
        <input id="end" type="datetime-local" value="2025-08-16T17:32" />
      </div>
      <!-- Advanced controls removed; server hard-codes cash, commission, sizing, and pacing -->
      <div class="cell">
        <label>&nbsp;</label>
        <button id="fast">Fast: Off</button>
      </div>
      <div class="cell">
        <label>Strategy name (file)</label>
        <input id="strategy_name" placeholder="example" />
      </div>
      <div class="cell">
        <button id="run">Run</button>
      </div>
      
      <div class="cell" style="min-width:360px;flex:1 1 360px;max-width:100%">
        <label>Inline Strategy (optional)</label>
        <textarea id="strategy_code" spellcheck="false" style="width:100%;height:120px;background:#0e151b;border:1px solid #1f2a33;color:#e6edf3;border-radius:6px;padding:8px;font-family:ui-monospace, SFMono-Regular, Menlo, monospace;">
import backtrader as bt

class InlineStrategy(bt.Strategy):
    params = dict(fast=10, slow=20)
    def __init__(self):
        self.fast = bt.ind.SMA(self.data.close, period=self.p.fast)
        self.slow = bt.ind.SMA(self.data.close, period=self.p.slow)
    def next(self):
        if not self.position and self.fast[0] > self.slow[0]:
            self.buy()
        elif self.position and self.fast[0] < self.slow[0]:
            self.close()
        </textarea>
      </div>
    </div>
  </header>
  <div id="chart" style="height:680px"></div>
  <div id="metrics"></div>
  <div id="trades" style="padding:10px;border-top:1px solid #1f2a33;background:#0e151b"></div>
  <div id="log"></div>

  <script>
    const log = (msg) => {
      const el = document.getElementById('log');
      el.textContent += `\n${new Date().toLocaleTimeString()} | ${msg}`;
      el.scrollTop = el.scrollHeight;
    };

        const chartEl = document.getElementById('chart');
    const chart = LightweightCharts.createChart(chartEl, {
      layout: { background: { color: "#0b0f14" }, textColor: "#e6edf3" },
      rightPriceScale: { borderColor: "#1f2a33" },
      timeScale: { borderColor: "#1f2a33" },
      grid: { vertLines: { color: "#11161b" }, horzLines: { color: "#11161b" } },
      autoSize: true,
      crosshair: { mode: 1 },
    });
    const candleSeries = chart.addCandlestickSeries();
    window.addEventListener('resize', () => chart.applyOptions({ width: chartEl.clientWidth }));

    function drawSeries(series) {
      const pad = 10;
      const names = Object.keys(series || {});
      let allValues = [];
      let totalCount = 0;
      names.forEach(name => {
        const data = series[name] || [];
        totalCount = Math.max(totalCount, data.length);
        data.forEach(p => {
          if (p && p.o != null) { allValues.push(p.h, p.l); }
          else if (p && p.close != null) { allValues.push(p.close); }
        });
      });
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (allValues.length === 0) return;
      const min = Math.min(...allValues);
      const max = Math.max(...allValues);
      const y = (v) => canvas.height - pad - ((v - min) / Math.max(1, (max - min))) * (canvas.height - pad * 2);
      const colors = ['#1f6feb','#2ea043','#bf5af2','#f778ba','#f0883e','#7ee787'];
      names.forEach((name, idx) => {
        const data = series[name] || [];
        if (!data || data.length === 0) return;
        ctx.strokeStyle = colors[idx % colors.length];
        ctx.lineWidth=1.5; ctx.beginPath();
        data.forEach((p, i) => {
          if (p && p.o != null) { drawCandle(i, p.o, p.h, p.l, p.c, '#26a69a', '#ef5350'); }
          else {
            const x = pad + i * ((canvas.width - pad*2) / Math.max(1,totalCount-1));
            const yy = y(p.close);
            if (i === 0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
          }
        });
        ctx.stroke();
      });
      function drawCandle(i, o,h,l,c, colorUp, colorDown){
        const x = pad + i * ((canvas.width - pad*2) / Math.max(1,totalCount-1));
        const isUp = c>=o;
        const color = isUp ? colorUp : colorDown;
        ctx.strokeStyle=color; ctx.fillStyle=color;
        const yO = y(o), yH = y(h), yL = y(l), yC = y(c);
        ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(x, yH); ctx.lineTo(x, yL); ctx.stroke();
        const bw = Math.max(2, (canvas.width - pad*2)/Math.max(1,totalCount-1) * 0.7);
        const top = Math.min(yO, yC), bot = Math.max(yO, yC);
        ctx.fillRect(x - bw/2, top, bw, Math.max(1, bot-top));
      }
}
    // ---- symbols dropdown logic ----
    const SYMBOLS = {
      forex: ["EUR/USD","GBP/USD","USD/JPY","XAU/USD","AUD/USD","USD/CAD"],
      stocks: ["AAPL","MSFT","TSLA","NVDA","SPY","QQQ"],
      crypto: ["BTC/USD","ETH/USD","SOL/USD","BNB/USD","XRP/USD"],
    };
    const marketEl = document.getElementById('market');
    const sourceEl = document.getElementById('source');
    const symbolSel = document.getElementById('symbol_select');
    const symbolInput = document.getElementById('symbol');
    function populateSymbols() {
      const market = marketEl.value;
      const list = SYMBOLS[market] || [];
      symbolSel.innerHTML = '';
      [...list, 'Custom...'].forEach(s => {
        const opt = document.createElement('option');
        opt.value = s;
        opt.textContent = s;
        symbolSel.appendChild(opt);
      });
      symbolSel.value = list[0] || 'Custom...';
      symbolInput.disabled = symbolSel.value !== 'Custom...';
      if (symbolSel.value !== 'Custom...') symbolInput.value = symbolSel.value;
      // lot multiplier control removed; nothing to set
    }
    symbolSel.addEventListener('change', () => {
      symbolInput.disabled = symbolSel.value !== 'Custom...';
      if (symbolSel.value !== 'Custom...') symbolInput.value = symbolSel.value;
    });
    marketEl.addEventListener('change', populateSymbols);
    sourceEl.addEventListener('change', populateSymbols);
    populateSymbols();

    let fastFlag = false;
    document.getElementById('fast').onclick = (e) => {
      e.preventDefault();
      fastFlag = !fastFlag;
      document.getElementById('fast').textContent = fastFlag ? 'Fast: On' : 'Fast: Off';
    };

    document.getElementById('run').onclick = async () => {
      const market = document.getElementById('market').value;
      const symbol = document.getElementById('symbol').value.trim(); const symbols = [symbol];
      const timeframe = document.getElementById('timeframe').value;
      const source = document.getElementById('source').value;
      const start = new Date(document.getElementById('start').value || new Date(Date.now()-1000*60*60*24*90)).toISOString();
      const end = new Date(document.getElementById('end').value || new Date()).toISOString();
      const cash = undefined; const commission = undefined; const slippage = undefined;
      const strategy_name_input = (document.getElementById('strategy_name').value || '').trim();
      const strategy_code_input = document.getElementById('strategy_code')?.value || '';
      // If a strategy name is provided, prefer it and do NOT send inline code
      const strategy_name = strategy_name_input.length ? strategy_name_input : null;
      const strategy_code = strategy_name ? null : (strategy_code_input.trim().length ? strategy_code_input : null);
      const size_percent = undefined; const sizing_mode = undefined; const lots_per_trade = undefined; const lot_multiplier = undefined; const leverage = undefined;
      const body = { symbols, timeframe, source, start, end, fast: fastFlag, strategy_name, strategy_code };
      // normalize symbol by source/market for convenience
      if (source === 'yfinance') {
        // yfinance: stocks like AAPL, FX like EURUSD=X, crypto like BTC-USD
        if (market === 'forex' && !symbol.endsWith('=X')) body.symbols = [symbol.replace('/', '') + '=X'];
        if (market === 'crypto' && symbol.includes('/')) body.symbols = [symbol.replace('/', '-')];
      }
      const res = await fetch('/backtest', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body)});
      const json = await res.json();
      if (!res.ok) { log('Error: ' + (json.error || res.statusText)); return; }
      const runId = json.run_id; log('Run ' + runId + ' started');
      // set price format based on market/symbol for realistic price scale
      (function setPriceFormat(){
        const sym = (body.symbols && body.symbols[0]) ? String(body.symbols[0]).toUpperCase() : '';
        let precision = 2;
        if (market === 'forex') {
          if (sym.includes('JPY')) precision = 3;        // e.g., USDJPY ~ 151.123
          else if (sym.includes('XAU')) precision = 2;    // Gold often 2 decimals
          else precision = 5;                              // Most FX majors 5 decimals
        } else if (market === 'crypto') {
          precision = sym.includes('BTC') ? 2 : 4;
        } else {
          precision = 2; // stocks default
        }
        candleSeries.applyOptions({ priceFormat: { type: 'price', precision, minMove: Math.pow(10, -precision) } });
      })();
      const ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws?run_id=' + runId);
      // reset series and markers for a fresh run
      window.series = {};
      window._markers = [];
      candleSeries.setData([]);
      candleSeries.setMarkers([]);
      ws.onmessage = (ev) => {
        if (!window._markers) window._markers = [];
        const msg = JSON.parse(ev.data);
        if (msg.type === 'status') log(msg.message);
        if (msg.type === 'bar') {
          // draw streaming prices as single series per symbol (append only)
          if (!window.series) window.series = {};
          Object.entries(msg.prices).forEach(([name, price]) => {
            if (!window.series[name]) window.series[name] = [];
            window.series[name].push(msg.ohlc?.[name] ? { time: msg.time, ...msg.ohlc[name] } : { time: msg.time, close: price });
          });
          const name = Object.keys(window.series)[0];
          const mapPoint = (p) => {
            const raw = p.time || "";
            let t = Date.parse(raw);
            if (!Number.isFinite(t)) {
              const base = raw.split(".")[0];
              t = Date.parse(base + "Z");
            }
            if (!Number.isFinite(t)) return null;
            const open = (p.o ?? p.close);
            const high = (p.h ?? p.close);
            const low = (p.l ?? p.close);
            const close = (p.c ?? p.close);
            if ([open,high,low,close].some(v => v == null || Number.isNaN(Number(v)))) return null;
            return { time: Math.floor(t/1000), open: Number(open), high: Number(high), low: Number(low), close: Number(close) };
          };
          const data = (window.series[name]||[]).map(mapPoint).filter(Boolean);
          if (data.length) {
            candleSeries.setData(data);
            candleSeries.setMarkers(window._markers || []);
            chart.timeScale().scrollToRealTime();
          }
        }
        if (msg.type === 'done') {
          const m = msg.metrics || {};
          const pv = msg.portfolio_value;
          const sharpe = (m.sharpe && (m.sharpe.sharperatio ?? m.sharpe['sharperatio'])) ?? null;
          const dd = (m.drawdown && (m.drawdown.max?.drawdown ?? m.drawdown.drawdown)) ?? null;
          const rtot = (m.returns && (m.returns.rtot ?? m.returns['rtot'])) ?? null;
          const rtot100 = (m.returns && (m.returns.rtot100 ?? (rtot!=null ? rtot*100 : null))) ?? null;
          const sqn = (m.sqn && (m.sqn.sqn ?? m.sqn['sqn'])) ?? null;
          const trades = (m.trades && (m.trades.total?.closed ?? m.trades.total?.total)) ?? null;
          const fmt = (x, d=4) => (x==null || isNaN(x)) ? '-' : Number(x).toFixed(d);
          const cur = (x) => (x==null || isNaN(x)) ? '-' : ('$' + Number(x).toFixed(2));
          const metricsDiv = document.getElementById('metrics');
          const s = (m && m.summary) || {};
          metricsDiv.innerHTML = `
            <div style="padding:10px;border-top:1px solid #1f2a33;background:#0e151b">
              <div style="display:flex;gap:16px;flex-wrap:wrap">
                <div><b>Starting Portfolio Value</b>: ${cur(s.pv_start)}</div>
                <div><b>Final Portfolio Value</b>: ${cur(s.pv_end ?? pv)}</div>
                <div><b>PV</b>: ${fmt(pv,2)}</div>
                <div><b>Total Return %</b>: ${fmt(rtot100,2)}</div>
                <div><b>Max DD %</b>: ${fmt(dd,2)}</div>
                <div><b>Sharpe</b>: ${fmt(sharpe,2)}</div>
                <div><b>SQN</b>: ${fmt(sqn,2)}</div>
                <div><b>Trades</b>: ${trades ?? '-'}</div>
              </div>
              <div style="margin-top:8px;display:flex;gap:16px;flex-wrap:wrap">
                <div><b>Strat Return %</b>: ${fmt(s.strategy_return_pct,2)}</div>
                <div><b>Buy&Hold %</b>: ${fmt(s.buy_hold_return_pct,2)}</div>
                <div><b>Strat vs B&H %</b>: ${fmt(s.strategy_vs_buy_hold_pct,2)}</div>
                <div><b>Strat Max DD %</b>: ${fmt(s.strategy_max_dd_pct,2)}</div>
                <div><b>B&H Max DD %</b>: ${fmt(s.buy_hold_max_dd_pct,2)}</div>
                <div><b>DD Diff %</b>: ${fmt(s.drawdown_diff_pct,2)}</div>
                <div><b>Win Rate %</b>: ${fmt(s.win_rate_pct,2)}</div>
              </div>
              <div style="margin-top:8px;display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px">
                <div style="background:#0e151b;border:1px solid #1f2a33;border-radius:8px;padding:8px">
                  <div style="font-weight:600;margin-bottom:4px">Trade Analysis</div>
                  <div>Total Trades: ${s.total_trades ?? '-'}</div>
                  <div>Winning Trades: ${s.won_trades ?? '-'}</div>
                  <div>Losing Trades: ${s.lost_trades ?? '-'}</div>
                  <div>Win Rate: ${fmt(s.win_rate_pct,2)}%</div>
                  <div>Average Profit per Trade: ${cur(s.avg_pnl_per_trade)}</div>
                  <div>Largest Win: ${cur(s.largest_win)}</div>
                  <div>Largest Loss: ${cur(s.largest_loss)}</div>
                </div>
              </div>
              
            </div>`;
          const tradesDiv = document.getElementById('trades');
          const rows = (msg.trades||[]).slice(-50).map(t => `<tr><td>${t.time}</td><td>${t.type}</td><td>${t.size??"-"}</td><td>${t.price??"-"}</td><td>${t.pnl??"-"}</td></tr>`).join("");
          tradesDiv.innerHTML = `<table style="width:100%;font-size:12px;color:#c9d1d9"><thead><tr><th>Time</th><th>Type</th><th>Qty</th><th>Price</th><th>PNL</th></tr></thead><tbody>${rows}</tbody></table>`;
          log('Done. PV=' + pv.toFixed(2));
        }
        if (msg.type === 'trade') {
          const t = msg.trade;
          let ts = Date.parse(t.time || "");
          if (!Number.isFinite(ts)) {
            const base = (t.time || "").split(".")[0];
            ts = Date.parse(base + "Z");
          }
          if (!Number.isFinite(ts)) return;
          const timeSec = Math.floor(ts/1000);
          const position = t.type === 'buy' ? 'belowBar' : (t.type === 'sell' ? 'aboveBar' : 'inBar');
          const color = t.type === 'buy' ? '#26a69a' : (t.type === 'sell' ? '#ef5350' : '#9e9e9e');
          const shape = t.type === 'buy' ? 'arrowUp' : (t.type === 'sell' ? 'arrowDown' : 'circle');
          window._markers.push({ time: timeSec, position, color, shape, text: `${t.type}` });
          candleSeries.setMarkers(window._markers);
        }
        if (msg.type === 'chart') { const name = Object.keys(msg.series)[0]; const data = msg.series[name].map(p => ({ time: Math.floor(new Date(p.time).getTime()/1000), open: p.o ?? p.close, high: p.h ?? p.close, low: p.l ?? p.close, close: p.c ?? p.close })); candleSeries.setData(data); chart.timeScale().scrollToRealTime(); }
      };
      ws.onclose = () => log('WebSocket closed');
    };
  </script>
</body>
</html>
